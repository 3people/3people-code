getbits에 관한 설명
0001 0101 1011 0011 <-- 이거를 (5555)
     ^^^^ ^ <-- 이만큼만 가져오고 싶음 (이때의 p = 11, n = 5 겠죠?)
step 1.
x >> (p+1-n) 이부분을 실행하면 (이때는 x >> 7 이겠죠?)
0000 0000 0010 1011 이 됩니다.
             ^ ^^^^

step 2.
~(~0 << n) 이부분을 실행할건데 (이때도 n = 5)
(*참고* ~0 은 1111 1111 1111 1111 입니다.)
  연산           결과
  ~0    1111 1111 1111 1111
 << 5   1111 1111 1110 0000
  ~     0000 0000 0001 1111 여기까지 잘 따라 왔을거라 믿습니다.

step 3.
(x >> (p+1-n)) & ~(~0 << n) 이제 두 바이너리 코드끼리 & 연산을 합니다.
(*참고* & 연산은 1 & 1 = 1, 1 & 0 = 0, 0 & 1 = 0, 0 & 0 = 0 입니다.)
그렇다면 결과값은 0000 0000 0000 1011 이 되겠죠?

x = 0001 0101 1011 0011, p = 11, n = 5
         ^^^^ ^
return = 0000 0000 0000 1011
                      ^ ^^^^

=======================================================================================

그럼 이제 setbits를 만들어 봅시다.
x = 0001 0100 0011 0011, y = 0000 0000 0001 1011, p = 12, n = 5 의 경우로 예를 들겠습니다.

step 1.
먼저 p부터 n까지를 0으로 만들어야 합니다.
0001 0100 0011 0011
   ^ ^^^^ <-- 이부분

    ~0      1111 1111 1111 1111
   <<n      1111 1111 1110 0000 (n = 5)
    ~       0000 0000 0001 1111
 <<(p-n+1)  0001 1111 0000 0000 (p = 12, n = 5)
    ~       1110 0000 1111 1111

이제 x 와 & 연산을 하면
0000 0000 0011 0011
   ^ ^^^^ 0으로 바뀌었죠?

step 2.
이제 y에서 왼쪽에서 부터 n개의 바이너리 코드를 가져옵니다. (getbits를 활용해도 됩니다.)
0000 0000 0001 1011
             ^ ^^^^ <-- 이부분

    ~0      1111 1111 1111 1111
   <<n      1111 1111 1110 0000
    ~       0000 0000 0001 1111

같은 방법으로 y 와 & 연산을 하면
0000 0000 0001 1011
             ^ ^^^^ <-- 여기인데 예제가 별로임.....

step 3.
이 두개의 값을 서로 합치면 우리가 원하는 값이 나오겠죠?
그러기위해 먼저 step 1.의 값과 step 2.의 값의 자릿수를 맞춰 줍니다.
            0000 0000 0001 1011
 << (p-n+1) 0001 1011 0000 0000 (p = 12, n = 5)
이제 step 1.의 값과 | 연산을 하면
(*참고* | 연산은 1 | 1 = 1, 1 | 0 = 1, 0 | 1 = 1, 0 | 0 = 0 입니다.)
0001 1011 0011 0011
   ^ ^^^^ <-- 이렇게 바뀐것을 확인 할 수 있습니다.
